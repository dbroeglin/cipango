// ========================================================================
// Copyright 2008-2010 NEXCOM Systems
// ------------------------------------------------------------------------
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at 
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ========================================================================

package org.cipango.media.api;

import java.util.ArrayList;
import java.util.List;

import org.mortbay.io.Buffer;
import org.mortbay.io.ByteArrayBuffer;

/**
 * Mixer is an audio multiplexer
 * 
 * It takes several inputs, mix them and provides one output. Mixer inputs and
 * the output will are all Buffers of the same size, using the same raw
 * format, i.e. mono-channel linear PCM 8000Hz signed 16 bits samples.
 * If one of the input is smaller than others, it will be processed up to its
 * end, and ignored after. If an audio stream is encoded, it has to be decoded
 * using its appropriate {@link Codec} class before it can be used by Mixer.
 * 
 * @author yohann
 */
public class Mixer implements Managed
{

    /**
     * Mix several Buffers into one Buffer. All inputs must use the same raw
     * format i.e. mono-channel linear PCM 8000Hz signed 16 bits samples. null
     * Buffers will be ignored, as well as empty buffers.
     * 
     * @param buffers the list of buffers to mix. All buffers should have the
     * same size
     * @return the unique Buffer generated by the mix of all inputs.
     */
    public Buffer mix(List<Buffer> buffers)
    {
        int length = 0;
        for (Buffer buffer: buffers)
        	if (buffer.length() > length)
        		length = buffer.length();
        Buffer output = new ByteArrayBuffer(length);
        List<Buffer> toBeRemoved = new ArrayList<Buffer>();
        while (buffers.size() > 0)
        {
        	float sum = 0;
            int numberOfStreams = 0;
        	for (Buffer buffer: buffers)
            	if (buffer.length() < 2)
            		toBeRemoved.add(buffer);
            	else
            	{
                	++numberOfStreams;
                    int firstByte = buffer.get();
                    int secondByte = buffer.get();
                    // little-endian input
                    //sum += (secondByte << 8 | firstByte) / numberOfStreams;
                    int sample = secondByte << 8 | firstByte;
                    if (sample > 32767)
                        sample -= 65536;
                    // sum += secondByte << 8 | firstByte;
                    sum += sample;
            	}
        	sum /= Math.sqrt(numberOfStreams);
            int roundedSum = Math.round(sum);
            // clip
            if (roundedSum > 32767)
                roundedSum = 32767;
            else if (roundedSum < -32767)
                roundedSum = -32767;
            // little-endian output
            output.put((byte)roundedSum);
            output.put((byte)(roundedSum >> 8));
            
            // remove empty buffers
            for (Buffer buffer: toBeRemoved)
            	buffers.remove(buffer);
            toBeRemoved.clear();
        }
        return output;
    }

}
